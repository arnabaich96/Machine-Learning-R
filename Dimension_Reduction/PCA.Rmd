---
title: "Principal Component Analysis"
author: "Arnab Aich"
output: 
  html_document:
    toc: true
    highlight: tango
    code_folding: hide
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    self_contained: true
    toc_depth: 3
    toc_float:
      collapsed: true
---

<link rel="stylesheet" type="text/css" href="../styles.css">

```{r,include=FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	comment = NA,
	echo = TRUE
)
```

# Introduction

In this document, we will implement Principal Component Analysis (PCA) on the **faces** dataset. PCA is a dimensionality reduction technique that is used to identify patterns in data and reduce the number of dimensions while retaining as much variance as possible. It works by finding the eigenvectors and eigenvalues of the data covariance matrix and projecting the data onto the eigenvectors with the largest eigenvalues.

## Loading required libraries

```{r include=FALSE}

packages <- c("imager","magick","magickGUI","tidyverse","png","ggplot2","dplyr","plotly","here","Thermimage","ggfortify")
lapply(packages, require, character.only = TRUE)
```

# Setting Up images as data matrices for further computation

```{r}
# seting data directory
dir1 <- here("Datasets/faces")
dir2 <- here("Datasets/background")

# making a list of .pgm files
pgm_faces <- list.files(dir1, pattern = ".pgm", full.names = TRUE)
pgm_background <- list.files(dir2, pattern = ".pgm", full.names = TRUE)
# Converting .pgm files to .png
for (file in pgm_faces) {
  img <- image_read(file)
  png_file <- gsub(".pgm", ".png", file)
  image_write(img, path = png_file, format = "png")
}
# --------------------------------------------------------------#
for (file in pgm_background) {
  img <- image_read(file)
  png_file <- gsub(".pgm", ".png", file)
  image_write(img, path = png_file, format = "png")
}
# list of .png files
png_files <- list.files(dir1,pattern = ".png", full.names = TRUE)
png_files_2 <- list.files(dir2,pattern = ".png", full.names = TRUE)

# read images into a list
faces <- lapply(png_files,readPNG)
background <- lapply(png_files_2,readPNG)

# convert images to a matrix
faces_matrix <- do.call(rbind, lapply(faces, as.vector))
background_matrix <- do.call(rbind, lapply(background, as.vector))
```

# a) PCA on Face Images & plot of eigenvalues after discarding highest 2

-   \*\* *prcomp:* The calculation is done by a singular value decomposition of the (centered and possibly scaled) data matrix, not by using eigen on the covariance matrix. This is generally the preferred method for numerical accuracy. \*\*

```{r warning=FALSE}
# perform PCA and extract eigenvalues

# Calculating mean
mean_face <- apply(faces_matrix,  2, mean)
# Compute the principal components of the centered face images
pca <- prcomp(faces_matrix, center = mean_face,scale. = TRUE)
eigenvalues <- pca$sdev^2

# plot sorted eigenvalues
eig_df <- round(data.frame(eigenvalues) %>% 
  mutate(eigenvalue_index = 1:length(eigenvalues)) %>%
  arrange(desc(eigenvalues)) %>%
  mutate(cumulative_proportion = cumsum(eigenvalues)/sum(eigenvalues),
         proportion = eigenvalues/sum(eigenvalues)))
# plot eigenvalues in decreasing order without the largest two  
ggplotly(ggplot(eig_df[-c(1,2),], aes(x = eigenvalue_index, y = eigenvalues)) +
  geom_line(stat = "identity",color = "green",linewidth = 0.9) +
  geom_point(stat = "identity",color = "blue")+
  labs(x = "Eigenvalue Index", y = "Eigen values",title = "Graph of 1st 50 eigen values(Zoomed)") +
  xlim(c(0.5,50))+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()))

```

-   **Note:** The plot is truncated at 50 because all the eigenvalues after that 0

# b) Graph of the coordinates of the faces projected to the 2D plane generated by the first and second principal component

```{r}
pc1 <- pca$rotation[,1]
pc2 <- pca$rotation[,2]
# Project the faces onto the 2D plane spanned by the principal components
proj <- faces_matrix %*% cbind(pc1, pc2)

# Plot the projected faces
ggplotly(ggplot(data = as.data.frame(proj), aes(x = pc1, y = pc2)) + geom_point(color= "purple") + xlab("PC1") + ylab("PC2")+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()))
```

# c) Graph of the coordinates from b) and the projections of the background patches on the same two principal components by the first and second principal component

```{r}
# Project the face images and background patches onto the first two principal components
centered_face <- scale(faces_matrix,center = mean_face)
face_projections <- predict(pca, centered_face)[, 1:2]

centered_bg <- scale(background_matrix,center = mean_face)
bg_projections <- predict(pca, centered_bg)[, 1:2]

# Plot the projections of the face images and background patches on the same graph
data <- rbind.data.frame(face_projections, bg_projections)
data$Index <- c(rep("Face", nrow(face_projections)), rep("Background", nrow(bg_projections)))


ggplotly(ggplot(data, aes(x = PC1, y = PC2, color = Index)) + geom_point() + xlab("PC1") + ylab("PC2")+theme_bw()+theme(legend.key.width = unit(0.1, 'cm'),legend.title = element_blank(),legend.text = element_text(size=10),legend.key.size =  unit(0.1, 'cm'),panel.grid.major = element_blank(), panel.grid.minor = element_blank())+scale_color_manual(values = c("Face" = "red","Background" = "black")))
```

# d) Reconstruction of Face Image *face00065.pgm* using 25 PCs

```{r}
img <- readPNG(here("Datasets/faces/face00065.png"))
X <- as.vector(img)
n_components <- 25
pca_components <- pca$rotation[, 1:n_components]
pca_weights <- X %*% pca_components
reconstructed <- pca_weights %*% t(pca_components)

# Reshape the reconstructed image to its original dimensions
reconstructed <- matrix(reconstructed, ncol = nrow(img), nrow = ncol(img))

# Plot the original and reconstructed images side by side
par(mfrow = c(1, 2))
image(mirror.matrix(t(img)), col = gray.colors(256), main = "Original",axes = FALSE)
image(mirror.matrix(t(reconstructed)), col = gray.colors(256), main = "Reconstructed",axes = FALSE)
```

# e) Reconstruction of Background Image *B1_00158.pgm* using 25 PCs

```{r}

img <- readPNG(here("Datasets/background/B1_00158.png"))
X <- as.vector(img)
n_components <- 25
pca_components <- pca$rotation[, 1:n_components]
pca_weights <- X %*% pca_components
reconstructed <- pca_weights %*% t(pca_components)

# Reshape the reconstructed image to its original dimensions
reconstructed <- matrix(reconstructed, ncol = nrow(img), nrow = ncol(img))

# Plot the original and reconstructed images side by side
par(mfrow = c(1, 2))
image(mirror.matrix(t(img)), col = gray.colors(256), main = "Original",axes = FALSE)
image(mirror.matrix(t(reconstructed)), col = gray.colors(256), main = "Reconstructed",axes = FALSE)
```

# f) The computed distances of the faces and the background points to the plane generated by the 25 largest PCs (on the y-axis) vs the coordinates of the projections on the second PC (on the x-axis) for the faces and background patches

```{r}
# Project faces and background onto the first 25 PCs
face_projections <- predict(pca, centered_face)[, 1:25]
bg_projections <- predict(pca, centered_bg)[, 1:25]

# Compute distances of faces and background to plane
face_distances <- apply(centered_face, 1, function(x) {
  x_projection <- predict(pca, t(x))[, 1:25]
  x_reconstruction <- pca$rotation[, 1:25] %*% x_projection
  norm(x - x_reconstruction)
})
background_distances <- apply(centered_bg, 1, function(x) {
  x_projection <- predict(pca, t(x))[, 1:25]
  x_reconstruction <- pca$rotation[, 1:25] %*% x_projection
  norm(x - x_reconstruction)
})

# Create data frames for plotting
face_df <- data.frame(PC2 = predict(pca, centered_face)[, 2], Distance = face_distances, Type = "Face")
background_df <- data.frame(PC2 = predict(pca, centered_bg)[, 2], Distance = background_distances, Type = "Background")
plot_df <- rbind(face_df, background_df)

# Create scatter plot
ggplotly(ggplot(plot_df, aes(x = PC2, y = Distance, color = Type)) +
  geom_point() + theme_bw()+
  labs(title = "Distances from Plane",x = "PC2", y = "Distance") +
  scale_color_manual(values = c("Face"="cyan","Background"="magenta")) +
  theme(legend.key.width = unit(0.1, 'cm'),legend.title = element_blank(),legend.text = element_text(size=10),legend.key.size =  unit(0.1, 'cm'),panel.grid.major = element_blank(), panel.grid.minor = element_blank()))

```

# g) Histogram of the distances obtained at f)

```{r}
# Plot the histogram with separate colors for the faces and background patches
ggplotly(ggplot(plot_df, aes(x = Distance, fill = Type,after_stat(density))) +
  geom_histogram(alpha = 0.75, position = "identity",bins = 20,color="black") +
  scale_fill_manual(values = c("Face"="orange","Background"= "violet")) + theme_bw()+
  labs(title = "Histogram of Distances", x = "Distance", y = "Density")+
  theme(legend.key.width = unit(0.15, 'cm'),legend.title = element_blank(),legend.text = element_text(size=10),legend.key.size =  unit(0., 'cm'),panel.grid.major = element_blank(), panel.grid.minor = element_blank()))

```
